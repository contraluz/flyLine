<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    #canvas {
      width: 500px;
      height: 400px;
      background: #503e2a;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <img src="./plane.png" id="plane" alt="plane">
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const image = document.getElementById("plane");

    let t = 0;

    function draw() {
      let p0 = {
          // 开始点坐标
          x: 20,
          y: 20
        },
        p1 = {
          // 控制点坐标
          x: 110,
          y: 50
        },
        p2 = {
          // 结束点坐标
          x: 150,
          y: 110
        };

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      let pb = {}; // 小球、箭头的x/y轴坐标
      let pb_behind = {}; // 箭头的上一一段时间的刻度行成的伪直线
      pb.x = computeCurvePoint(p0.x, p1.x, p2.x, t);
      pb.y = computeCurvePoint(p0.y, p1.y, p2.y, t);
      pb_behind.x = computeCurvePoint(p0.x, p1.x, p2.x, t - 0.05);
      pb_behind.y = computeCurvePoint(p0.y, p1.y, p2.y, t - 0.05);
      ctx.save();
      ctx.strokeStyle = 'rgba(255, 193, 7,1)';
      ctx.lineWidth = 2;

      // 开始画小球/箭头
      arc(pb, pb_behind);
      ctx.restore();

      // 设置曲线的线性渐变
      function createGradient(ctx) {
        let grd = ctx.createLinearGradient(0, 0, 170, 0);
        grd.addColorStop(0, 'rgba(255, 193, 70, 0)');
        grd.addColorStop(t, 'rgba(255, 193, 7, 1)');
        grd.addColorStop(1, 'rgba(255, 193, 70, 0)');
        return grd;
      }
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      // 设置曲线位置
      ctx.quadraticCurveTo(p1.x, p1.y, p2.x, p2.y);
      // 设置曲线其它信息
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;
      ctx.strokeStyle = createGradient(ctx);
      // 整体模糊操作，会影响箭头的视觉效果
      // ctx.shadowColor = 'rgb(255, 193, 7)';
      // ctx.shadowBlur = 5;
      // 绘制曲线
      ctx.stroke();

      t += 0.01;

      if (t > 1) {
        t = 0;
      }

      requestAnimationFrame(draw);
    }

    function drawArrow(ctx, fromX = 0, fromY = 0, toX = 10, toY = 0, theta = 10, headlen = 10, width = 1, color = "#000") {
      if (!ctx) {
        return console.error("ctx不存在");
      }

      // 计算各角度和对应的P2,P3坐标
      let angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI,
        angle1 = (angle + theta) * Math.PI / 180,
        angle2 = (angle - theta) * Math.PI / 180,
        topX = headlen * Math.cos(angle1),
        topY = headlen * Math.sin(angle1),
        botX = headlen * Math.cos(angle2),
        botY = headlen * Math.sin(angle2);

      ctx.save();
      ctx.beginPath();

      let arrowX = fromX - topX,
        arrowY = fromY - topY;

      // 箭头附带的直线，不需要，用draw里的二次贝塞尔曲线
      // ctx.moveTo(arrowX, arrowY);
      // ctx.moveTo(fromX, fromY);
      // ctx.lineTo(toX, toY);
      arrowX = toX + topX;
      arrowY = toY + topY;
      // 从左侧的一半箭头开始画
      ctx.moveTo(arrowX, arrowY);
      // 画到当前与曲线的交点
      ctx.lineTo(toX, toY);
      arrowX = toX + botX;
      arrowY = toY + botY;
      // 从交点画上右侧的一半箭头
      ctx.lineTo(arrowX, arrowY);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();
      ctx.restore();
    }

    function arc(pb, pb_behind) {
      // 小球
      // ctx.beginPath();
      // ctx.arc(pb.x, pb.y, 2, 0, Math.PI * 2);
      // ctx.stroke();

      // arrow箭头
      drawArrow(ctx, pb_behind.x, pb_behind.y, pb.x, pb.y, 15, 15, 3, "rgb(255, 193, 7)");

      // 飞机
      // ctx.drawImage(image, pb.x, pb.y, 20, 20);
    }

    function computeCurvePoint(a0, a1, a2, t) {
      let b = (1 - t) * (1 - t) * a0 + 2 * (1 - t) * t * a1 + t * t * a2;
      return b;
    }

    draw()
  </script>
</body>

</html>